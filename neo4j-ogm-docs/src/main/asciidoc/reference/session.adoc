[[reference-programming-model-session]]
= Session

The `Session` provides the core functionality to persist objects to the graph and load them in a variety of ways.

== Session Configuration

A `Session` is used to drive the object-graph mapping framework.
It keeps track of the changes that have been made to entities and their relationships.
The reason it does this is so that only entities and relationships that have changed get persisted on save, which is particularly efficient when working with large graphs.
Once an entity is tracked by the session, reloading this entity within the scope of the same session will result in the session cache returning the previously loaded entity.
However, the subgraph in the session will expand if the entity or its related entities retrieve additional relationships from the graph.

If you want to fetch fresh data from the graph, then this can be achieved by using a new session or clearing the current sessions context using `org.neo4j.ogm.session.Session.clear()`.

The lifetime of the `Session` can be managed in code.
For example, associated with single _fetch-update-save_ cycle or unit of work.

If your application relies on long-running sessions then you may not see changes made from other users and find yourself working with outdated objects.
On the other hand, if your sessions have too narrow a scope then your save operations can be unnecessarily expensive, as updates will be made to all objects if the session isn't aware of the those that were originally loaded.

There's therefore a trade off between the two approaches.
In general, the scope of a `Session` should correspond to a "unit of work" in your application.




== Basic operations

Basic operations are limited to CRUD operations on entities and executing arbitrary Cypher queries; more low-level manipulation of the graph database is not possible.

[NOTE]
There is no way to manipulate relationship- and node-objects directly.

Given that the Neo4j OGM framework is driven by Cypher queries alone, there's no way to work directly with `Node` and `Relationship` objects in remote server mode.
Similarly, Traversal Framework operations are not supported, again because the underlying query-driven model doesn't handle it in an efficient way.

If you find yourself in trouble because of the omission of these features, then your best options are:

. Write a Cypher query to perform the operations on the nodes/relationships instead.
. Write a Neo4j server extension and call it over REST from your application.

Of course, there are pros and cons to both of these approaches, but these are largely outside the scope of this document.
In general, for low-level, very high-performance operations like complex graph traversals you'll get the best performance by writing a server-side extension.
For most purposes, though, Cypher will be performant and expressive enough to perform the operations that you need.


== Entity persistence

`Session` allows to `save`, `load`, `loadAll` and `delete` entities with transaction handling and exception translation managed for you.
The eagerness with which objects are retrieved is controlled by specifying the 'depth' argument to any of the load methods.


== Cypher queries

The `Session` also allows execution of arbitrary Cypher queries via its `query`, `queryForObject` and `queryForObjects` methods.
Cypher queries that return tabular results should be passed into the `query` method which returns an `org.neo4j.ogm.model.Result`.
This consists of `org.neo4j.ogm.model.QueryStatistics` representing statistics of modifying cypher statements if applicable, and an `Iterable<Map<String,Object>>` containing the raw data, which can be either used as-is or converted into a richer type if needed.
The keys in each `Map` correspond to the names listed in the return clause of the executed Cypher query.

`queryForObject` specifically queries for entities and as such, queries supplied to this method must return nodes and not individual properties.
//For the query methods that retrieve mapped objects, the recommended query format is to return a path, which should ensure that known types get mapped correctly and joined together with relationships as appropriate.
[NOTE]
====
In the current version, custom queries do not support paging, sorting or a custom depth.
In addition, it does not support mapping a path to domain entities, as such, a path should not be returned from a Cypher query.
Instead, return nodes and relationships to have them mapped to domain entities.

Modifications made to the graph via Cypher queries directly will not be reflected in your domain objects within the session.
====



[[reference-cypher]]
== Cypher

Cypher is Neo4j's powerful query language.
It is understood by all the different drivers in the OGM which means that your application code should run identically, whichever driver you choose to use.
This makes application development much easier: you can use the Embedded Driver for your integration tests, and then plug in the Http Driver or the Bolt Driver when deploying your code into a production client-server environment.
